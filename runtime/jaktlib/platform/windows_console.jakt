
import jakt::platform::console_common { ReadResult }
import jakt::platform::utility { null }


import extern "windows.h" {
    extern struct HANDLE {}
    extern struct CONSOLE_READCONSOLE_CONTROL {
        nLength: u32
        nInitialChars: u32
        dwCtrlWakeupMask: u32
        dwControlKeyState: u32
    }
    extern fn GetStdHandle(anon nStdHandle: c_int) -> HANDLE
} before_include define { NOMINMAX = "1" }

// NOTE: This header and stdlib.h defines min and max macros that we aren't going to use and that stop our build process.
import extern "errhandlingapi.h" {
    extern fn GetLastError() -> c_int
} before_include define { NOMINMAX = "1" }

import extern c "stdlib.h"  {
    // TODO: This functionality should be available through AK's stdlib.
    // I only found Kernel\Library\Stdlib.h, and not sure if we're OK to use it.
    // Other utilities like AK\ByteBuffer.h use __builtin_memmove() directly. Maybe that's fine.
    extern fn memmove(dest: raw void, src: raw void, count: usize)
} before_include define { NOMINMAX = "1" }

import extern c "fileapi.h" {} before_include define { NOMINMAX = "1" }

// Wrapper around ReadConsole: https://learn.microsoft.com/en-us/windows/console/readconsole
// Overwrites `buffer` with up to `buffer_size` bytes read from stdin.
// Returns how much it read and whether this is the last read that can yield
// data.
fn read_from_stdin(buffer: raw c_char, buffer_size: usize) throws -> ReadResult {

    // https://learn.microsoft.com/en-us/windows/console/getstdhandle
    mut nStdHandle: c_int = 0
    unsafe { cpp { "nStdHandle = STD_INPUT_HANDLE;" }}




    let hConsoleInput = GetStdHandle(nStdHandle)

    mut is_invalid_handle: bool = false
    unsafe { cpp { "is_invalid_handle = hConsoleInput == INVALID_HANDLE_VALUE;" }}

    guard not is_invalid_handle else {
        let err = GetLastError() as! i32
        throw Error::from_errno(err)
    }

    mut is_console: bool = false

    mut lpmode: u32 = 0

    unsafe { cpp {
        // https://stackoverflow.com/questions/22972071/is-there-a-way-to-determine-whether-stdout-is-pointing-to-the-console
        "DWORD _unused_lpmode;"
        "is_console = (GetConsoleMode(hConsoleInput, &_unused_lpmode)) != FALSE;"

        "lpmode = _unused_lpmode;"
    }}

    mut read_count: usize = 0


    mut ok: bool = false


    // https://learn.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-readfile

    // NOTE: cpp is required because I need an `unsigned long *` (LPDWORD) which to C++ is different from `unsigned int *`
    unsafe { 
        let buffer_size_u32 = buffer_size as! u32
        cpp {
            "DWORD readCount_DWORD;"
            "ok = ReadFile(hConsoleInput, buffer, buffer_size_u32, &readCount_DWORD, NULL);"
            "read_count = static_cast<size_t>(readCount_DWORD);"
        }
    }

    // We cannot use ReadFile's return in conjuction with readCount
    // because the handle could be a pipe.
    mut has_eof: bool = false

    if not ok {
        // It may be a pipe, so check EOF/more data conditions on the result:
        // https://learn.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-readfile#pipes
        let err = GetLastError() as! i32
        mut is_broken_pipe: bool = false
        unsafe { cpp { "is_broken_pipe = err == ERROR_BROKEN_PIPE;" }}
        mut is_more_data: bool = false
        unsafe { cpp { "is_more_data = err == ERROR_MORE_DATA;" }}
        if is_broken_pipe { 
            has_eof = true
        } else if is_more_data {
            has_eof = false // should call read again
        } else {
            eprintln("[windows_console] ReadFile not ok: {}", err)
            throw Error::from_errno(err)
        }
    }



    return ReadResult(
        count: read_count
        at_eof: has_eof
    )
}
