
import jakt::platform::console_common { ReadResult }
import jakt::platform::utility { null }

// NOTE: These headers define 'min' and 'max' macros that we aren't going to use and that stop our build process, since they are included in '__unified_forward.h'.


import extern "windows.h" {
    extern struct HANDLE {}
    extern struct CONSOLE_READCONSOLE_CONTROL {
        nLength: u32
        nInitialChars: u32
        dwCtrlWakeupMask: u32
        dwControlKeyState: u32
    }
    extern fn GetStdHandle(anon nStdHandle: c_int) -> HANDLE
} before_include define { NOMINMAX = "1" }

import extern c "errhandlingapi.h" {
    extern fn GetLastError() -> c_int
} before_include define { NOMINMAX = "1" }

import extern c "stdlib.h"  {
    // TODO: This functionality may be available through AK's stdlib.
    // I only found Kernel\Library\Stdlib.h, and not sure if we're OK to use it.
    // Other utilities like AK\ByteBuffer.h use __builtin_memmove() directly. Maybe that's fine.
    extern fn memmove(dest: raw void, src: raw void, count: usize)
} before_include define { NOMINMAX = "1" }

import extern c "fileapi.h" {
    extern struct OVERLAPPED {}
    extern fn WriteFile(hFile: HANDLE, lpBuffer: raw void, nNumberOfBytesToWrite: u32, lpNumberOfBytesWritten: raw u32, lpOverlapped: raw OVERLAPPED) -> bool
} before_include define { NOMINMAX = "1" }

// write to standard output. May throw on things like broken pipes.
// When using the thrown code in upper abstracted code, make sure to distinct
// between each platform's error codes. This does not unify them.
// Note that since Windows allows writes up to 4GiB, the rest will match this // upper bound.
fn write_raw_stdout(buffer: raw c_char, count: u32) throws {



    // https://learn.microsoft.com/en-us/windows/console/getstdhandle
    mut nStdHandle: c_int = 0
    unsafe { cpp { "nStdHandle = STD_OUTPUT_HANDLE;" }}

    let out_handle = GetStdHandle(nStdHandle)


    // https://learn.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-writefile
    mut ok: bool = false
    unsafe { cpp {
        // NOTE: cpp is needed here because lpNumberOfBytesWritten is `unsigned long *`, which is not currently representable in Jakt.
        "ok = WriteFile(out_handle, buffer, count, NULL, NULL);"
    } }


    guard ok else {
        throw Error::from_errno(GetLastError() as! i32)
    }

}

// Wrapper around ReadConsole: https://learn.microsoft.com/en-us/windows/console/readconsole
// Overwrites `buffer` with up to `buffer_size` bytes read from stdin.
// Returns how much it read and whether this is the last read that can yield
// data.
fn read_from_stdin(buffer: raw c_char, buffer_size: usize) throws -> ReadResult {

    // https://learn.microsoft.com/en-us/windows/console/getstdhandle
    mut nStdHandle: c_int = 0
    unsafe { cpp { "nStdHandle = STD_INPUT_HANDLE;" }}




    let hConsoleInput = GetStdHandle(nStdHandle)

    mut is_invalid_handle: bool = false
    unsafe { cpp { "is_invalid_handle = hConsoleInput == INVALID_HANDLE_VALUE;" }}

    guard not is_invalid_handle else {
        let err = GetLastError() as! i32
        throw Error::from_errno(err)
    }

    mut read_count: usize = 0


    mut ok: bool = false


    // https://learn.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-readfile

    // NOTE: cpp is required because I need an `unsigned long *` (LPDWORD) which to C++ is different from `unsigned int *`
    unsafe { 
        let buffer_size_u32 = buffer_size as! u32
        cpp {
            "DWORD readCount_DWORD;"
            "ok = ReadFile(hConsoleInput, buffer, buffer_size_u32, &readCount_DWORD, NULL);"
            "read_count = static_cast<size_t>(readCount_DWORD);"
        }
    }

    // We cannot use ReadFile's return in conjuction with read_count because
    // the handle could (and the LSP server expects it to) be a pipe.
    mut has_eof: bool = false

    if not ok {
        // It may be a pipe, so check EOF/more data conditions on the result:
        // https://learn.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-readfile#pipes
        let err = GetLastError() as! i32
        mut is_broken_pipe: bool = false
        unsafe { cpp { "is_broken_pipe = err == ERROR_BROKEN_PIPE;" }}
        mut is_more_data: bool = false
        unsafe { cpp { "is_more_data = err == ERROR_MORE_DATA;" }}
        if is_broken_pipe { 
            has_eof = true
        } else if is_more_data {
            has_eof = false // should call read again
        } else {
            eprintln("[windows_console] ReadFile not ok: {}", err)
            throw Error::from_errno(err)
        }
    }



    return ReadResult(
        count: read_count
        at_eof: has_eof
    )
}
