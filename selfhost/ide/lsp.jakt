import compiler { Compiler }
import ide::logger { LogFile, Log }
import ide::reader as jsonrpc
import ide::message { Event, Dump, MessageId, ErrorCode, send_simple_error, send_response, dump_key_value, dump_key, dump_string }
import ide::parse_json { JsonValue }
import ide::results as results

struct LspState {
    initialized: bool = false
    shutdown_requested: bool = false
    exit_requested: bool = false
    // TODO: if the parent process is not alive then the server should exit
    // its process. Should we poll?
    parent_process: i32? = None
    textDocument: TextDocumentState = TextDocumentState()
}

struct TextDocumentState {
    opened_uris: [String:TextDocument] = [:]
}



fn lsp_server(compiler: Compiler) throws -> c_int {

    // FIXME: The logfile should be customizable and/or removable.
    // This will mean that we will be wasting time creating strings for logging and not producing them anywhere. If any formatter API comes along, we will be able to remove them completely.
    let logfile = LogFile::create(filename: "log.txt") 
    defer logfile.close()

    mut reader =  jsonrpc::Reader::adopt_stdin(log: Log(file: logfile, name: "reader"))

    defer reader.destroy()

    let lsplog = Log(file: logfile, name: "lsp")

    lsplog.log("Listening on stdin")

    mut state = LspState()

    while not state.exit_requested {
        lsplog.log("Awaiting next message")
        let next_msg = reader.next_message()
        guard next_msg is Some(message) else {
            lsplog.log("Encountered end of input on the message")
            break
        }

        let event = try Event::deserialize(message) catch err {
            lsplog.log(format("Error deserializing event: {}", err))
            // do not send parse error back; since notifications also exist
            // and we're skipping them.
            // send_simple_error(id: MessageId::Int(0), code: -32700)
            continue
        }

        handle_event(event, toplevel: message, &lsplog, &mut state)
    }

    // https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#shutdown
    if state.shutdown_requested {
        return 0
    } else {
        return 1
    }
}


fn handle_event(event: Event, toplevel: [String:JsonValue], lsplog: &Log, state: &mut LspState) {
    lsplog.log(format("event: {}", event))

    match event {
        Request(id) => {
            if state.shutdown_requested {
                send_simple_error(&id, code: ErrorCode::InvalidRequest)
            } else {
                match event.method {
                    "initialize" => {
                        initialize(&id, toplevel, state, lsplog)
                    }
                    "shutdown" => {
                        lsplog.log("Shutdown requested")
                        state.shutdown_requested = true

                    }
                    else => {}
                }
            }
        }
        Notification => {
            if event.method == "exit" {
                lsplog.log("Exit requested")
                state.exit_requested = true
            } else if state.initialized and not state.shutdown_requested {
                // Check notification
                match event.method {
                    "textDocument/didOpen" => did_open(toplevel, state, &lsplog)
                    "textDocument/didClose" => {
                        guard toplevel.get("params") is Some(jparams) else { return }
                        guard jparams is Obj(params) else { return }
                        did_close(params, state, &lsplog)
                    }
                    else => {}
                }
            }
            // Drop notification
        }
    }
}

struct TextDocument {
    version: i64
    text: String
    uri: String
    // TODO: get file id from compiler
}

fn did_close(params: [String:JsonValue], state: &mut LspState, lsplog: &Log) {
    let log = lsplog.sub(name: "textDocument/didClose")

    guard params.get("textDocument") is Some(jtdoc) else { return } 
    guard jtdoc is Obj(tdoc) else { return }

    guard tdoc.get("uri") is Some(juri) else { return }
    guard juri is Str(uri) else { return }

    log.log(format("Closed {}", uri))

    // unregister that file.
    state.textDocument.opened_uris.remove(uri)

}

fn did_open(toplevel: [String:JsonValue], state: &mut LspState, lsplog: &Log) {
    let log = lsplog.sub(name: "textDocument/didOpen")


    guard toplevel.get("params") is Some(jparams) else { return }
    guard jparams is Obj(params) else { return }

    guard params.get("textDocument") is Some(jtdoc) else { return }
    guard jtdoc is Obj(tdoc) else { return }

    guard tdoc.get("uri") is Some(juri) else { return }
    guard juri is Str(uri) else { return }

    guard tdoc.get("languageId") is Some(jlangid) else { return }
    guard jlangid is Str(language_id) else { return }
    guard language_id == "jakt" else { return } 

    guard tdoc.get("version") is Some(jversion) else { return }
    guard jversion is Num(nversion) else { return }
    guard nversion is Integer(version) else { return }

    guard tdoc.get("text") is Some(jtext) else { return }
    guard jtext is Str(text) else { return }

    log.log(format("Opened {}", uri))

    let td = TextDocument(version, text, uri)


    // TODO: update compiler on file
    state.textDocument.opened_uris.set(uri, td)
}


fn initialize(id: &MessageId, toplevel: [String:JsonValue], state: &mut LspState, lsplog: &Log) {

    // https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#initialize
    let log = lsplog.sub(name: "initialize")

    guard not state.initialized else {
        log.log("invalid request: server is already initialized")
        send_simple_error(id, code: ErrorCode::AlreadyInitialized)
        return
    }

    if toplevel.get("processId") is Some(process_id_obj) {
        match process_id_obj {
            Num(n) => {
                if n is Integer(i) {
                    state.parent_process = i as? i32
                } else {
                    log.log("invalid processId")
                    send_simple_error(id, code: ErrorCode::InvalidParams)
                }
            }
            Null => {
                state.parent_process = None
            }
            else => {
                log.log("invalid processId")
                send_simple_error(id, code: ErrorCode::InvalidParams)
            }
        }
    }

    // TODO: workspace folders
    // TODO: client capabilities

    state.initialized = true
    log.log("Server initialized")

    // TODO: send server capabilities
    send_result_fn(
        id, 
        fn(anon out: &mut StringBuilder) {
            dump_server_capabilities(out)
        }
    )
}

fn dump_server_capabilities(anon out: &mut StringBuilder) {

    out.append(b'{')

    defer out.append(b'}')

    eprintln("current build: {:#}", out.to_string())

    dump_key("capabilities", out, is_first: true)

    {
        out.append(b'{')
        defer out.append(b'}')

        dump_key("textDocumentSync", out, is_first:  true)

        {
            out.append(b'{')
            defer out.append(b'}')

            // Notify on open/close
            dump_key_value("openClose", &true, out, is_first: true)
        }
    }
}

fn send_result_fn(id: &MessageId, anon dumpfn: fn(anon out: &mut StringBuilder) -> void) {
    send_response(id, fn[&dumpfn](anon out: &mut StringBuilder) {
        out.append(b',')
        dump_string("result", out)
        out.append(b':')
        dumpfn(out)
    })
}

fn send_result<R requires(Dump)>(id: &MessageId, anon res: &R) {
    send_response(id, fn[&res](anon out: &mut StringBuilder) {
        dump_key_value("result", res, out)
    })
}
