import utility { panic }
import ide::parse_json { JsonValue }
import jakt::platform { platform_console }
import jakt::platform::utility { null }
import platform_console() { write_raw_stdout }

struct Message {
    jsonrpc: String

    fn deserialize(anon obj: [String:JsonValue]) throws -> Message {
        guard obj.contains("jsonrpc") and obj["jsonrpc"] is Str(s) else {
            throw Error::from_string_literal("invalid message: missing key")
        }
        guard s == "2.0" else {
            throw Error::from_string_literal("invalid message: jsonrpc must be 2.0")
        }
        return Message(jsonrpc: s)
    }

}

enum MessageId implements(Dump) {
    Str(String),
    Int(i32),

    fn deserialize(anon obj: JsonValue) throws -> MessageId => match obj {
        Str(s) => MessageId::Str(s),
        Num(n) => {
            guard n.as_i32() is Some(i) else {
                throw Error::from_string_literal("invalid id: should be integer or string")
            }
            yield MessageId::Int(i)
        }
        else => {
            throw Error::from_string_literal("invalid id: should be integer or string")
        }
    }

    fn dump(this, anon out: &mut StringBuilder) {
        match this {
            Str(s) => { dump_string(s, out) }
            Int(i) => { out.append(format("{}", i)) }
        }
    }
}

enum Event {
    method: String

    Notification
    Request(id: MessageId)

    fn deserialize(anon obj: [String:JsonValue]) throws -> Event {
        guard obj.contains("method") else {
            throw Error::from_string_literal("invalid: missing 'method'")
        }
        guard obj["method"] is Str(method) else {
            throw Error::from_string_literal("invalid: 'method' should be a string")
        }

        if obj.get("id") is Some(id_obj) {
            return Event::Request(method, id: MessageId::deserialize(id_obj))
        } else {
            return Event::Notification(method)
        }

    }
}

trait Dump {
    fn dump(this, anon out: &mut StringBuilder)
}

type i32 implements(Dump) {
    // NOTE: The inline here serves a purpose: the compiler doesn't generate
    // correct code if it isn't there. It will instead use `(i32_value).dump`
    // which is invalid C++ for type i32.
    [[inline(always)]]
    fn dump(this, anon out: &mut StringBuilder) {
        out.append(format("{}", this))
    }
}

type JsonValue implements(Dump) {
    fn dump(this, anon out: &mut StringBuilder) {
        dump_any(&this, out)
    }
}

type String implements(Dump) {
    [[inline(always)]]
    fn dump(this, anon out: &mut StringBuilder) {
        dump_string(this, out)
    }
}

type bool implements(Dump) {
    [[inline(always)]]
    fn dump(this, anon out: &mut StringBuilder) {
        if this {
            out.append("true")
        } else {
            out.append("false")
        }
    }
}

fn dump_key(anon key: String, anon out: &mut StringBuilder, is_first: bool = false) {
    if not is_first {
        out.append(b',')
    }
    dump_string(key, out)
    out.append(b':')
}

fn dump_any(anon obj: &JsonValue, anon out: &mut StringBuilder) {
    match obj {
        Str(s) => { dump_string(s, out) }
        Num(n) => match n {
            Integer(i) => { out.append(format("{}", i)) }
            Decimal(d) => { out.append(format("{}", d)) }
        }
        Obj(ob) => {
            out.append(b'{')

            mut it = ob.iterator()

            let first = it.next()
            if first is Some(tuple) {
                let (key, val) = tuple
                dump_key_value(key, &val, out, is_first: true)
            }

            for (key, val) in it {
                dump_key_value(key, &val, out)
            }

            out.append(b'}')
        }
        Arr(arr) => {
            out.append(b'[')

            if arr.size() != 0 {
                dump_any(&arr[0], out)
                for i in 1..arr.size() {
                    out.append(b',')
                    dump_any(&arr[i], out)
                }
            }

            out.append(b']')
        }
        True => { out.append("true") }
        False => { out.append("false") }
        Null => { out.append("null") }
    }
}

fn dump_key_value<T requires(Dump)>(anon key: String, anon val: &T, anon out: &mut StringBuilder, is_first: bool = false) {
    if not is_first {
        out.append(b',')
    }
    dump_string(key, out)
    out.append(b':')
    val.dump(out)
}


// FIXME: all of these are negative, but the compiler thinks it's not a constant value.
enum ErrorCode : i32 {
    InvalidRequest = 32600i32,
    InvalidParams = 32602i32,
    ParseError = 32700i32
    AlreadyInitialized = 32002
}

fn send_simple_error(id: &MessageId, code: ErrorCode) {
    let icode = -(code as! i32)
    send_response(id, fn[icode](anon out: &mut StringBuilder) {
        dump_key_value("code", &icode, out)
    })
}

import ide::logger { LogFile, Log }

fn send_raw(anon result: String) {
    mut sb = StringBuilder::create()
    // NOTE: format() and out() convert newlines to CRLF automatically under windows, and doesn't on non-windows. Hence, to ensure that we get the proper bytes,
    // I have to format things more manually.
    sb.append(format("Content-Length: {}", result.length()))
    sb.append(b'\r')
    sb.append(b'\n')
    sb.append(b'\r')
    sb.append(b'\n')
    sb.append(result)
    let wholemsg = sb.to_string()

    // Don't expect the length to surpass 4GiB.
    // FIXME: The const_cast here is fine, but it could be avoidable by
    // having the compiler support const raw pointers.
    mut buffer: raw c_char = null<raw c_char>()
    unsafe { cpp { "buffer = const_cast<char *>(wholemsg.characters());" }}
    must write_raw_stdout(buffer, count: wholemsg.length() as! u32)

    // FIXME: This is for debugging, shouldn't be here.
    let lastdump = try LogFile::create(filename: "raw.txt") catch {
        return
    }
    defer lastdump.close()
    lastdump.log(wholemsg)
}

fn send_response(id: &MessageId, anon dumpfn: fn(anon out: &mut StringBuilder) -> void) {
    mut out = StringBuilder::create()

    out.append(b'{')
    dump_key_value("jsonrpc", &"2.0", &mut out, is_first: true)
    dump_key_value("id", &id, &mut out)

    dumpfn(&mut out)

    out.append(b'}')

    send_raw(out.to_string())
}

// NOTE: This should be replaced by StringBuilder::append_escaped_for_json when it correctly dumps all UTF-8 into UTF-8 encoded JSON
// Encodes a StringView into UTF-8 JSON, following
// RFC7158 section 7: https://www.rfc-editor.org/rfc/rfc7158.txt
fn dump_string(anon s: String, out: &mut StringBuilder) {
    out.append('"')
    for cp in s.code_points() {
        // escape codepoint if required
        match cp {
            '"' => {
                out.append(b'\\')
                out.append(b'"')
            }
            // special recognizable escapes
            '\\' => {
                out.append(b'\\')
                out.append(b'\\')
            }
            '\r' => {
                out.append(b'\\')
                out.append(b'r')
            }
            '\t' => {
                out.append(b'\\')
                out.append(b't')
            }
            '\n' => {
                out.append(b'\\')
                out.append(b'n')
            }
            // must be escaped using a single \u
            0u32..0x0020u32 | 0x80u32..0x10000u32 => {
                out.append(b'\\')
                out.append(b'u')
                encode_utf16_json(out, cp as! u16)
            }

            // single byte characters
            0x20u32..0x80u32 => {
                out.append(cp as! u8)
            }

            // surrogate pairs
            0x010000u32..0x110000u32 => {
                // To encode each hex UTF-16, following
                // RFC2781 section 2.1: https://datatracker.ietf.org/doc/html/rfc2781.html
                // uprime can be represented in 20 bits.
                let uprime = cp - 0x10000u32

                // 4 * 2 + 2 = 10 bits free.
                // The "third" 0 from 0x8(0b1000) is needed to distinguish between first and second pair (8/C)
                mut w1 = 0xD800u16
                mut w2 = 0xDC00u16

                // 10 high order bits of U' to 10 low-order bits of w1
                w1 |= (uprime >> 10) as! u16
                // 10 low order bits of U' to 10 low-order bits of w2
                w2 |= (uprime & 0x3FF) as! u16

                encode_utf16_json(out, w1)
                encode_utf16_json(out, w2)
            }
            else => {
                panic("Cannot encode code point to JSON: out of spec range")
            }
        }
    }
    // ending quote.
    out.append('"')
}

fn encode_utf16_json(out: &mut StringBuilder, anon cp: u16) {
    encode_nibble(out, cp >> (4*3))
    encode_nibble(out, cp >> (4*2))
    encode_nibble(out, cp >> (4*1))
    encode_nibble(out, cp >> (4*0))
}

fn encode_nibble(out: &mut StringBuilder, anon nibble: u16) {
    let value = (nibble & 0xf) as! u8
    if value >= 10 {
        out.append(b'a' + (value - 10))
    } else {
        out.append(b'0' + value)
    }
}

