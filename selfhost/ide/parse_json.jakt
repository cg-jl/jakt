import relative parent::utility { is_whitespace, is_ascii_digit, is_ascii_hexdigit, panic }

import extern "AK/Math.h" {
    namespace AK {
        extern fn pow<T>(anon a: T, anon b: T) -> T
    }
}


enum JsonValue {
    Str(String)
    Arr([JsonValue])
    Obj([String:JsonValue])
    // jsonrpc distinguishes between integer and decimal
    Num(Number)
    True
    False
    Null
}

enum Number {
    Integer(i64),
    Decimal(f64)

    fn as_i32(this) -> i32? => match this {
        Integer(n) => n as? i32,
        Decimal => None
    }
}

// parses a JSON object, expecting the source to have the full object in it
fn parse(source: String) throws -> JsonValue {
    mut index = 0uz
    return parse_with_position(&mut index, &source)
}

// yields (fraction, exponent) if there is one
fn parse_fraction(index: &mut usize, source: &String) -> (f64?, i64?) {
    mut maybe_fraction: f64? = None

    if index < source.length() and source.byte_at(*index) == b'.' {
        index++
        let start_index = *index
        mut fraction = 0f64
        while index < source.length() and is_ascii_digit(source.byte_at(*index)) {
            fraction *= 10f64
            fraction += (source.byte_at(*index) - b'0') as! f64
            index++
        }
        for i in start_index..(*index) {
            fraction /= 10f64
        }
        maybe_fraction = fraction
    }

    mut maybe_exponent: i64? = None

    if index < source.length() and (source.byte_at(*index) == b'e' or source.byte_at(*index) == b'E') {
        index++
        mut exponent: i64 = 1
        if index < source.length() and source.byte_at(*index) == b'-' {
            index++
            exponent = -1
        } else if index < source.length() and source.byte_at(*index) == b'+' {
            index++
            exponent = 1
        }
        while index < source.length() and is_ascii_digit(source.byte_at(*index)) {
            exponent *= 10
            exponent += (source.byte_at(*index) - b'0') as! i64
        }
        maybe_exponent = exponent
    }

    return (maybe_fraction, maybe_exponent)
}

fn parse_number_known_integer(index: &mut usize, source: &String, int_part: i64) -> Number {
    let (maybe_fraction, maybe_exponent) = parse_fraction(index, source)

    if maybe_fraction is None and maybe_exponent is None {
        return Number::Integer(int_part)
    }

    mut val = int_part as! f64

    if maybe_fraction is Some(frac) {
        val += frac
    }

    if maybe_exponent is Some(exp) {
        val *= AK::pow<f64>(10f64, exp as! f64)
    }


    return Number::Decimal(val)

}

fn parse_number_nonzero(index: &mut usize, source: &String) -> i64 {
    mut val = (source.byte_at(*index) - b'0') as! i64
    index++
    while index < source.length() and is_ascii_digit(source.byte_at(*index)) {
        val *= 10
        val += (source.byte_at(*index) - b'0') as! i64
        index++
    }
    return val
}


fn whitespace(index: &mut usize, source: &String) {
    while index < source.length() {
        match source.byte_at(*index) {
            b' ' | b'\n' | b'\r' | b'\t' => {
                index++
                continue
            }
            else => { break }
        }
    }

}

// Parses one value from the source, keeping track of the position
fn parse_with_position(index: &mut usize, source: &String) throws -> JsonValue {
    loop {
        guard index < source.length() else {
            throw Error::from_string_literal("unexpected EOF")
        }

        match source.byte_at(*index) {
            b' ' | b'\n' | b'\r' | b'\t' => {
                index++
                continue
            }
            b'f' => {
                if index + 4 < source.length() and
                    source.byte_at(*index + 1) == b'a' and
                    source.byte_at(*index + 2) == b'l' and
                    source.byte_at(*index + 3) == b's' and
                    source.byte_at(*index + 4) == b'e' {

                    index += 5
                    return JsonValue::False()
                }
            }
            b't' => {
                if index + 3 < source.length() and
                    source.byte_at(*index + 1) == b'r' and
                    source.byte_at(*index + 2) == b'u' and
                    source.byte_at(*index + 3) == b'e' {

                    index += 4
                    return JsonValue::True
                }
            }
            b'n' => {
                if index + 3 < source.length() and
                    source.byte_at(*index + 1) == b'u' and
                    source.byte_at(*index + 2) == b'l' and
                    source.byte_at(*index + 3) == b'l' {

                    index += 4
                    return JsonValue::Null
                }
            }
            b'-' => {
                index++
                guard index < source.length() else {
                    throw Error::from_string_literal("unexpected EOF on number")
                }
                let int_part = match source.byte_at(*index) {
                    b'0' => 0i64,
                    b'1'..(b'9' + 1) => parse_number_nonzero(index, source),
                    else => {
                        throw Error::from_string_literal("number has only negative sign")
                    }
                }
                return JsonValue::Num(match parse_number_known_integer(index, source, int_part) {
                    Integer(i) => Number::Integer(-i),
                    Decimal(d) => Number::Decimal(-d),
                })
            }
            b'0' => {
                index++
                return JsonValue::Num(parse_number_known_integer(index, source, int_part: 0))
            }
            b'1'..(b'9' + 1) => {
                let int_part = parse_number_nonzero(index, source)
                return JsonValue::Num(parse_number_known_integer(index, source, int_part))
            }
            b'"' => {
                index++
                mut sb = StringDecoder()
                loop {
                    guard index < source.length() else {
                        throw Error::from_string_literal("unexpected EOF on string literal")
                    }

                    match source.byte_at(*index) {
                        b'"' => {
                            index++
                            break
                        }
                        b'\\' => {
                            index++
                            guard index < source.length() else {
                                throw Error::from_string_literal("unexpected EOF on string literal escape code")
                            }
                            match source.byte_at(*index) {
                                b'u' => {
                                    index++
                                    guard index + 4 <= source.length() else {
                                        throw Error::from_string_literal("unexpected EOF on string literal '\\u'")
                                    }
                                    mut value: u16 = 0
                                    for i in 0uz..4uz {
                                        guard is_ascii_hexdigit(source.byte_at(*index + i)) else {
                                            throw Error::from_string_literal("invalid '\\u' escape code")
                                        }
                                        value <<= 4
                                        value |= decode_nibble(source.byte_at(*index + i))
                                    }
                                    sb.add(value)
                                    index += 4
                                }
                                b'"' => {
                                    index++
                                    sb.add(b'"' as! u16)
                                }

                                b'\\' => {
                                    index++
                                    sb.add(b'\\' as! u16)
                                }
                                b'/' => {
                                    index++
                                    sb.add(b'/' as! u16)
                                }
                                b'b' => {
                                    index++
                                    sb.add(0x08)
                                }
                                b'f' => {
                                    index++
                                    sb.add(0xC0)
                                } 
                                b'n' => {
                                    index++
                                    sb.add(b'\n' as! u16)
                                }
                                b'r' => {
                                    index++
                                    sb.add(b'\r' as! u16)
                                }
                                b't' => {
                                    index++
                                    sb.add(b'\t' as! u16)
                                }
                                else => {
                                    throw Error::from_string_literal("invalid escape code")
                                }
                            }
                        }
                        else => {
                            sb.add(source.byte_at(*index) as! u16)
                            index++
                        }
                    }
                }
                return JsonValue::Str(sb.end())
            }
            b'[' => {
                index++

                mut arr: [JsonValue] = []

                loop {
                    guard index < source.length() else {
                        throw Error::from_string_literal("unexpected EOF on array")
                    }

                    match source.byte_at(*index) {
                        b']' => {
                            index++
                            break
                        }
                        else => {
                            arr.push(parse_with_position(index, source))
                            guard index < source.length() else {
                                throw Error::from_string_literal("unexpected EOF on array")
                            }
                            whitespace(index, source)
                            match source.byte_at(*index) {
                                b']' => { 
                                    index++
                                    break 
                                }
                                b',' => { 
                                    index++
                                    continue 
                                }
                                else => {
                                    throw Error::from_string_literal("unexpected character at end of array value")
                                }
                            }
                        }
                    }
                }
                return JsonValue::Arr(arr)
            }
            b'{' => {
                index++

                mut obj: [String:JsonValue] = [:]

                loop {
                    guard index < source.length() else {
                        throw Error::from_string_literal("unexpected EOF on object")
                    }

                    match source.byte_at(*index) {
                        b'}' => {
                            index++
                            break
                        }
                        else => {
                            let maybe_key = parse_with_position(index, source)
                            guard maybe_key  is Str(key) else {
                                throw Error::from_string_literal("key in object is not a string")
                            }
                            whitespace(index, source)
                            guard index < source.length() and source.byte_at(*index) == b':' else {
                                throw Error::from_string_literal("':' is expected after an object key")
                            }
                            index++
                            whitespace(index, source)

                            let value = parse_with_position(index, source)
                            whitespace(index, source)

                            obj.set(key, value)

                            match source.byte_at(*index) {
                                b'}' => {
                                    index++
                                    break
                                }
                                b',' => { 
                                    index++
                                    continue 
                                }
                                else => {
                                    throw Error::from_string_literal("unexpected character at end of object value")
                                }
                            }
                        }
                    }
                }
                return JsonValue::Obj(obj)
            } 
            else => {}
        }
        throw Error::from_string_literal("unexpected character at start of value")
    }
}

struct StringDecoder {
    sb: StringBuilder = StringBuilder::create()
    state: DecodeState = DecodeState::AtNext

    fn end(this) throws -> String {
        guard .state is AtNext else {
            throw Error::from_string_literal("surrogate pair starts and doesn't have an end")
        }
        return .sb.to_string()
    }

    fn add(mut this, anon next: u16) throws {
        //  Decoding from UTF16 to UTF8 is done via this table:
        //  https://es.wikipedia.org/wiki/UTF-8
        match .state {
            AtNext => match next {
                // ascii
                0x00u16..0x80u16 => {
                    .sb.append(next as! u8)
                }
                // Basic Multilingual Plane: two-byte encoded
                0x80u16..0x800u16 => {
                    .sb.append(((next >> 6) as! u8) | 0xC0)
                    .sb.append((next & 0x3F) as! u8 | 0x80)
                }
                // Surrogate pair start
                0xD800u16..0xDC00u16 => {
                    .state = DecodeState::FirstSurrogate(next)
                }
                // Surrogate pair end (failure)
                0xDC00u16..0xDD00u16 => {
                    throw Error::from_string_literal("surrogate pair end without start")
                }

                // Basic Multilingual Plane: three-byte encoded
                else => {
                    .sb.append((next >> 12) as! u8 | 0xE0)
                    .sb.append(((next >> 6) & 0x3F) as! u8 | 0x80)
                    .sb.append((next & 0x3F) as! u8 | 0x80)
                }


            }
            FirstSurrogate(wzy) => {
                let wzy = next
                let yx = next
                guard yx >= 0xDC00 and yx < 0xDD00 else {
                    throw Error::from_string_literal("surrogate pair second value must be in 0xDC00..=0xDCFF range")
                }

                let u = ((wzy >> 6) & 0xf) + 1

                .sb.append((u >> 2) as! u8 | 0xF8)
                .sb.append((u & 0x3) as! u8 << 4 |((wzy >> 2) & 0xf) as! u8 |0x80)
                .sb.append((wzy & 0x3) as! u8 << 4 |((yx >> 6)& 0xf) as! u8 |0x80)
                .sb.append((yx & 0x3F) as! u8 | 0x80)

                .state = DecodeState::AtNext
            }
        }
    }
}

enum DecodeState {
    AtNext
    FirstSurrogate(u16)
}


fn decode_nibble(anon ch: u8) throws -> u16 {
    return match ch {
        b'0'..(b'9' +1) => (ch - b'0') as! u16
        b'a'..(b'f' + 1) => (ch - b'a' + 10) as! u16
        b'A'..(b'F' + 1) => (ch - b'A' + 10) as! u16
        else => {
            throw Error::from_string_literal("invalid code nibble")
        }
    }
}
